/**
 * POS Checkout API Route
 * Processes sales transactions with inventory validation
 */

import { createClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'

interface CheckoutItem {
  productId: string
  inventoryId: string
  quantity: number
  price: number
  discount: number
}

interface CheckoutRequest {
  storeId: string
  cashierId: string
  customerId: string | null
  items: CheckoutItem[]
  subtotal: number
  tax: number
  discount: number
  total: number
  paymentMethod: 'cash' | 'card' | 'mobile' | 'other'
  notes: string
}

export async function POST(request: Request) {
  try {
    const supabase = await createClient()

    // Verify authentication
    const {
      data: { user },
    } = await supabase.auth.getUser()

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body: CheckoutRequest = await request.json()

    // Validate request
    if (!body.items || body.items.length === 0) {
      return NextResponse.json({ error: 'Cart is empty' }, { status: 400 })
    }

    if (!body.storeId || !body.cashierId) {
      return NextResponse.json(
        { error: 'Store and cashier information required' },
        { status: 400 }
      )
    }

    // Verify user has permission (must be assigned to the store)
    const { data: profile } = await supabase
      .from('profiles')
      .select('store_id, role')
      .eq('id', user.id)
      .single()

    if (!profile || profile.store_id !== body.storeId) {
      return NextResponse.json(
        { error: 'You are not authorized to process sales for this store' },
        { status: 403 }
      )
    }

    // Validate inventory availability for all items
    const inventoryChecks = await Promise.all(
      body.items.map(async (item) => {
        const { data: inventory } = await supabase
          .from('product_inventory')
          .select('quantity, product_id, store_id')
          .eq('id', item.inventoryId)
          .eq('store_id', body.storeId)
          .single()

        return {
          inventoryId: item.inventoryId,
          available: inventory?.quantity || 0,
          requested: item.quantity,
          valid: inventory && inventory.quantity >= item.quantity,
        }
      })
    )

    // Check for insufficient stock
    const insufficientStock = inventoryChecks.filter((check) => !check.valid)
    if (insufficientStock.length > 0) {
      return NextResponse.json(
        {
          error: 'Insufficient inventory',
          details: insufficientStock.map((check) => ({
            inventoryId: check.inventoryId,
            available: check.available,
            requested: check.requested,
          })),
        },
        { status: 400 }
      )
    }

    // Create sale record with pending status
    // Note: sale_number is auto-generated by database trigger
    const saleData = {
      store_id: body.storeId,
      cashier_id: body.cashierId,
      customer_id: body.customerId,
      subtotal: body.subtotal,
      tax: body.tax,
      discount: body.discount,
      total: body.total,
      payment_method: body.paymentMethod,
      status: 'pending' as const,
      notes: body.notes,
    }

    const { data: sale, error: saleError } = await supabase
      .from('sales')
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      .insert(saleData as any)
      .select('id, sale_number')
      .single()

    if (saleError) {
      console.error('Sale creation error:', saleError)
      return NextResponse.json(
        { error: 'Failed to create sale record' },
        { status: 500 }
      )
    }

    // Create sale items
    const saleItems = body.items.map((item) => ({
      sale_id: sale.id,
      product_id: item.productId,
      inventory_id: item.inventoryId,
      quantity: item.quantity,
      unit_price: item.price,
      discount: item.discount,
      subtotal: item.price * item.quantity - item.discount,
    }))

    const { error: itemsError } = await supabase
      .from('sale_items')
      .insert(saleItems)

    if (itemsError) {
      console.error('Sale items creation error:', itemsError)

      // Rollback: delete the sale record
      await supabase.from('sales').delete().eq('id', sale.id)

      return NextResponse.json(
        { error: 'Failed to create sale items' },
        { status: 500 }
      )
    }

    // Update sale status to completed - this triggers inventory deduction
    const { error: updateError } = await supabase
      .from('sales')
      .update({ status: 'completed' })
      .eq('id', sale.id)

    if (updateError) {
      console.error('Sale completion error:', updateError)

      // Rollback: delete sale items and sale
      await supabase.from('sale_items').delete().eq('sale_id', sale.id)
      await supabase.from('sales').delete().eq('id', sale.id)

      return NextResponse.json(
        { error: 'Failed to complete sale' },
        { status: 500 }
      )
    }

    // Note: Inventory deduction happens automatically via database trigger

    return NextResponse.json({
      success: true,
      saleId: sale.id,
      saleNumber: sale.sale_number,
    })
  } catch (error) {
    console.error('Checkout error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
